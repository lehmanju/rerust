\chapter{ReRust}
\label{rerust}

To help with understanding the concepts of \ac{FRP} we introduce our \textsf{ReRust} \ac{DSL} by example.

\section{Examples}
We will first describe a simple chat application example and introduce our language informally. Afterwards we present a more technical example that illustrates important properties of \textsf{ReRust}.

\subsection{Chat example}
\label{rerust:ex:chat}
This example illustrates how \ac{FRP} can be used in communication applications, which we have adopted from \cite{ChatExamplePaper}. But instead of \textsf{ReScala} code, Listing \ref{lst:chat-example} shows its implementation in \textsf{ReRust}. The example resembles a peer-to-peer chat application, in which each peer runs the same code. The code shows how incoming messages are processed and update the internal state of a peer.
How peers communicate is irrelevant for our example, we are only assuming that all messages arrive at some point. 

\begin{lstlisting}[language=ReRust,style=colouredRust,caption=Chat example written in ReRust,label=lst:chat-example]
let name = Var::<String>(String::new());
let text = Evt::<String>();
let message = (text, name).map(
    |(t, n) : (String, String)| -> String {
        format!("{}: {}", n, t)
});
let room1 = message.fold(Vec::new(),
    |mut vec: Vec<String>, msg: String| -> Vec<String> {
        vec.push(msg);
        vec
});
let room2 = Var::<Vec<String>>(
    vec![String::from("Me: a constant message")]
);
let index = Var::<usize>(0);
let room_list = (room1, room2).map(
    |(room1, room2) : (Vec<String>, Vec<String>)| 
        -> Vec<Vec<String>> {
            vec![room1, room2]
});
let selected_room = (room_list, index).map(
    |(room_list, index) : (Vec<Vec<String>>, usize)|
        -> Vec<String> {
            room_list[index].clone()
});
\end{lstlisting}

A \textsf{ReRust} program is essentially modeling a \ac{DG} which can be compiled into a regular program. The corresponding \ac{DG} for Listing \ref{lst:chat-example} can be seen in Figure \ref{fig:graph-chat}. Arrows between adjacent \ac{DG} nodes illustrate data flowing in direction of the arrows. Bold nodes are called \emph{source reactives} and can only have outgoing arrows. All other nodes are \emph{derived reactives} which have at least one incoming edge but optional outgoing edges. Lines 1, 2, 12 and 15 in Listing \ref{lst:chat-example} define a new instance of a source reactive, derived reactives are defined in lines 17, 21, 30 and 35. Source reactives provide an interface for a reactive program to receive new inputs from. There are two different variants of available input interfaces, \lstinline{Var} and \lstinline{Evt}. \lstinline{Var} nodes save state (like variables) and can be altered from regular Rust code, whereas \lstinline{Evt} nodes provide a stream interface and are intended to be used for event streams. Derived reactives are derived from source reactives, they get data on their incoming edge and output data on their outgoing edge.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}
    \tikzset{vertex/.style = {shape=rectangle,draw,minimum size=1.5em}}
    \tikzset{edge/.style = {->,> = latex'}}
    \node[vertex] (name) at (0,0) {\textbf{name}};
    \node[vertex] (text) at (0,1) {\textbf{text}};
    \node[vertex] (message) at (1.5,0) {message};
    \node[vertex] (room1) at (3,0) {room1};
    \node[vertex] (room2) at (3,1) {\textbf{room2}};
    \node[vertex] (index) at (4.7,1) {\textbf{index}};
    \node[vertex] (roomlist) at (4.7,0) {room\_list};
    \node[vertex] (selectedroom) at (7,0) {selected\_room};
    \draw[edge] (name) to (message);
    \draw[edge] (text) to (message);
    \draw[edge] (message) to (room1);
    \draw[edge] (room1) to (roomlist);
    \draw[edge] (room2) to (roomlist);
    \draw[edge] (index) to (selectedroom);
    \draw[edge] (roomlist) to (selectedroom);
    \end{tikzpicture}
    \caption{Dataflow graph of the chat example}
    \label{fig:graph-chat}
\end{figure}

The syntax of \textsf{ReRust} is actually a subset of valid Rust syntax. It can broadly be described as a skeleton for regular Rust computational code where the skeleton describes a \ac{DG} and regular Rust code describes computations attached to various nodes. Therefore, semantics of \textsf{ReRust} are different from Rust but not unfamiliar because we borrow already established patterns for reactive languages from \textsf{ReScala} and \textsf{ReactiFi}. At the core of a valid \textsf{ReRust} program is a list of \lstinline{let}-statements that define new named nodes in the \ac{DG}. Additional anonymous nodes are defined by a syntax element that looks like a function call. Computations are embedded in these function calls as regular Rust closures with complete Rust feature support.

In our example we use \lstinline{map} and \lstinline{fold} but some more types of derived reactives are available which we will describe later in section \ref{rerust:impl}. These reactives are connected to the reactive that is defined on the left hand side of the dot, forming a new edge from the left to the right reactive. This behavior can be observed in line 23 where the output of \lstinline{message} is connected to a \lstinline{fold} which then forms the \lstinline{room1}-reactive. Folding a stream of values is the primary way of preserving state between subsequent evaluations as it allows accessing the accumulator value from the last evaluation. For \lstinline{room1} all incoming messages are accumulated into a list.

The \lstinline{(a, b, ...)} syntax connects multiple outputs with one reactive input as seen in line 3. The outputs of \lstinline{text} and \lstinline{name} are routed to the input of \lstinline{map}, forming a new reactive \mbox{\lstinline{message}.} If an input of \lstinline{message} changes, its associated \lstinline{map} closure is reevaluated which, in this case, results in an output change for \lstinline{message} as well. But reevaluation of reactives behaves differently depending on whether the changed input is an \lstinline{Evt} or a \lstinline{Var}. Let us assume that the current state of \lstinline{Var} is "Bob" and that there is a new incoming event in queue for \lstinline{text}. Now the output of \lstinline{text} has changed, resulting in a reevaluation of \lstinline{message} but only because we can access the value of \lstinline{name}, even if it hasn't changed. If we look at the opposite scenario, no update for \lstinline{text} but \lstinline{name} changes from "Bob" to "Alice", we can not reevaluate \lstinline{message} because the state of \lstinline{text} is undefined at this time. This rule also applies to all derived reactives that are stateless and depend on \lstinline{Evt} reactives.

Although until now we have only talked about source reactives functioning as inputs, the principle of change propagation remains the same for derived reactives (Fig. \ref{fig:graph-chat}), only that their inputs can not be altered from "outside". Looking at our example application we can observe that every time a new message is available we add it to \lstinline{room1}. Unlike \lstinline{map}, \lstinline{fold} behaves similarly to \lstinline{Var} in that it stores state and its value is defined even it does not change. Now if \lstinline{room1} contains a new message we will see that the \lstinline{room_list} reactive will change as well as it combines \lstinline{room1} and \lstinline{room2} into one list. With an additional input, called \lstinline{index}, a user can change the \lstinline{selected_room}. Via an auto-generated \ac{API} it is possible to submit an observer function to listen for possible changes of reactives. In this case, one would simply observe \lstinline{selected_room} and update the \ac{UI} accordingly.

\subsection{Diamond pattern}

Now that we have seen how \textsf{ReRust} can be used in practical applications we present a more technical example. This should illustrate what guarantees \textsf{ReRust} provides at runtime. Before looking at the code we will analyze the corresponding \ac{DG} to Listing \ref{lst:diamond-pattern} in Figure \ref{fig:diamond-pattern}.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}
    \tikzset{vertex/.style = {shape=rectangle,draw,minimum size=1.5em}}
    \tikzset{edge/.style = {->,> = latex'}}
    \node[vertex] (x) at (0,0.5) {\textbf{x} = 1};
    \node[vertex] (y) at (2,1) {y = x * 2};
    \node[vertex] (z) at (2,0) {z = x * 3};
    \node[vertex] (t) at (4,0.5) {t = y + z};
    \draw[edge] (x) to (y);
    \draw[edge] (x) to (z);
    \draw[edge] (y) to (t);
    \draw[edge] (z) to (t);
    \end{tikzpicture}
    \caption{Diamond pattern}
    \label{fig:diamond-pattern}
\end{figure}

If \lstinline{x} changes from 1 to 2, the value of \lstinline{t} should change from 5 to 10. \textsf{ReRust} guarantees that parallel reactives which eventually have a common descendant, will all be evaluated before its descendant. If this were not the case, we would not only have to evaluate \lstinline{t} twice but also have a false value temporarily. In a schedule that executes \lstinline{x}, \lstinline{y}, \lstinline{t} and then \lstinline{z}, \lstinline{t} we would have a temporary value of 7 for \lstinline{t} before it switches to 10. This is the case, because after \lstinline{x} changes, \lstinline{y} updates and the first evaluation of \lstinline{t} will use the new value of \lstinline{y} but the old value of \lstinline{z} which results in a so-called \emph{glitch}. To prevent this, we topologically sort each \ac{DG} before code generation and therefore satisfy the property of \emph{glitch freedom}.

\begin{lstlisting}[language=Rust,style=colouredRust,caption=Diamond pattern written in ReRust,label=lst:diamond-pattern]
let x = Var::<u32>(1u32);
let y = x.map(|x: u32| -> u32 {x * 2});
let z = x.map(|x: u32| -> u32 {x * 3});
let t = (y,z).map(|(y,z): (u32,u32)| -> u32 {y + z});
\end{lstlisting}

\subsection{Usage}
Until now we have only seen how \rerust can be used to write reactive programs. This section covers its usage and how to interface with standard Rust code. For this purpose we will present code that is used to interface with our chat example from \ref{rerust:ex:chat}. Listing \ref{lst:chat-example-usage} shows how interacting with \rerust looks. For this code snippet to be executable one must insert the source code from Listing \ref{lst:chat-example} at line 5.

\begin{lstlisting}[language=Rust,style=colouredRust,caption=Chat example usage,label=lst:chat-example-usage]
mod generated {
    use rerust::rerust_gen;
    
    rerust_gen! {
        // include chat example ReRust code here
    }
}

fn main() {
    let mut prog = generated::Program::new();
    let mut sink = prog.sink();

    let observer = Rc::new(RefCell::new(observer_cb)) as Rc<_>;
    prog.observe_selected_room(
        Rc::downgrade(&observer));

    sink.send_name(format!("Alice"));
    sink.send_text(format!("Hi bob!"));
    sink.send_text(format!("My name is Alice"));
    sink.send_name(format!("Bob"));
    sink.send_text(format!("Hi Alice, nice to meet you!"));
    sink.send_index(1);
    for _ in 0..6 {
        prog.run();
    }
}

fn observer_cb(history: &Vec<String>) {
    println!("history: {:?}", history);
}
\end{lstlisting}

The macro invocation at line 4 then instructs our \rerust compiler to read the inputs and generate new code accordingly. All structs and functions are accessible at the same module the macro is used. It is advised to embed the invocation into another module and only have one invocation of \lstinline{rerust_gen!} per module to prevent name collisions. After code is generated a \lstinline{Program} object is created in line 10. The code at lines 11-14 registers a new observer for \lstinline{selected_room}. Lines 16-24 send some exemplary changes to the queue in which only one input at a time is changed. Finally, we call \lstinline{prog.run()} 7 times to execute all queued changes. Although there are only 6 changes sent, one additional execution is required to initialize all reactives before the first proper run. The for-loop in line 22 is usually replaced by a \lstinline|loop { ... }| construct or worker thread which automatically handles all pending changes. At last, running Listing \ref{lst:chat-example-usage} produces following output:
\begin{lstlisting}[numbers=none]
history: []
history: ["Alice: Hi bob!"]
history: ["Alice: Hi bob!", "Alice: My name is Alice"]
history: ["Alice: Hi bob!", "Alice: My name is Alice", "Bob: Hi Alice, nice to meet you!"]
\end{lstlisting}

\section{Implementation}
\label{rerust:impl}

Now we will introduce \rerust syntax and semantics formally in section \ref{rerust:impl:formal}. Afterwards we will cover our compiler architecture and its generated code in detail in section \ref{rerust:impl:compiler}.

\subsection{Formal language definition}
\label{rerust:impl:formal}
A formal grammar for \textsf{ReRust} is given in the following grammar. Most of the syntax features and functionality have been modeled after Reactifi~\citep{reactifi} to provide a familiar interface. 

\begin{indentgrammar}{<groupinner>}
<prog> ::=  `let' <varname> `=' <stmt> `;' 
     \alt `let' <varname> `=' <stmt> `;' <prog>

<varname> ::= ( a-z | 0-9 )+

<source> ::= `Var' `::' `<' <type> `>' `(' <rexpr> `)' \alt `Evt' `::' `<' <type> `>' `()'

<stmt> ::= <map> | <fold> | <choice> | <filter>

<expr> ::= <varname> | <stmt>

<inputs> ::= <expr> | <group>

<group> ::= `(' <groupinner> `)'
    
<groupinner> ::= <expr> \alt <expr> `,' <groupinner>

<map> ::= <inputs> `.' `map' `(' <closure> `)'

<fold> ::= <inputs> `.' `fold' `(' <rexpr> `,' <closure> `)'

<choice> ::= <expr> `||' <expr>

<filter> ::= <expr> `.' `filter' `(' <closure> `)'

<closure> ::= \emph{Rust closure}

<rexpr> ::= \emph{Rust expression}

<type> ::= \emph{Rust type}
\end{indentgrammar}

At the core of each \rerust program is a list of \lstinline{let <name> = ...;} statements which describe connections in the \ac{DG}. The intuition is that the part on the right hand site of \lstinline{=} represents a \ac{DG} node which can be accessed by \lstinline{<name>} in subsequent statements. The output of \lstinline{<name>} can then be used multiple times as input for different nodes by using it on the right hand side as \lstinline{<stmt>}. These statements essentially look like a chain of function calls with the difference that they specify new dependencies instead of one time computations. A dot connects the \lstinline{<stmt>} on the left to a reactive on the right which can be \lstinline{<map>}, \lstinline{<fold>} or \lstinline{<filter>}. If it is desired to use the values of multiple reactives, one can use \lstinline{<group>} to combine their outputs and use their values as Rust tuple \lstinline{(...)}. \lstinline{<choice>} has a different syntax because it always needs exactly two reactives as inputs. It requires them to output the same type and can be used to perform a computation if either one of them has changed. Finally, all transforming reactives parse a Rust closure \lstinline{<closure>} describing a computation and in case of \lstinline{<fold>} an initialization expression \lstinline{<expr>}. Both of them cohere with standard Rust syntax. We will discuss the semantics of these syntax elements in section \ref{rerust:impl:compiler:transform}.

\subsection{Compiler architecture}
\label{rerust:impl:compiler}
Compiling \rerust programs to Rust code is done in 3 passes. First, we \emph{parse} a list of tokens into an \ac{AST}. In stage 2 this \ac{AST} is then \emph{transformed} into a annotated \ac{DG}. And finally, code is \emph{generated} for each node and edge of the \ac{DG}.

All features of our compiler are implemented using Rust's procedural macros which allow us to transform a list of tokens. The benefit of this approach is that we don't need to provide a custom infrastructure for our language but don't have to make compromises either. Procedural macros can be defined by defining a function that takes a \lstinline{TokenStream} as input and outputs another \lstinline{TokenStream}. The input stream contains all tokens that are inside the curly braces of a macro invocation, so \lstinline|macro! { some tokens }| would map to a token stream with \lstinline{some} and \lstinline{tokens} as elements. The procedural macro definition of \rerust is in Listing \ref{lst:procmacro}.

\begin{lstlisting}[language=Rust,style=colouredRust,caption=Procedural macros,label=lst:procmacro]
#[proc_macro]
pub fn rerust_gen(input: TokenStream) -> TokenStream {
    // compiler code
}
\end{lstlisting}

\subsection{Parsing}
At the beginning of the compilation process we only have access to \rerust source in form of a \lstinline{TokenStream}. Before any transformations can take place we need to parse all tokens into an \ac{AST}. A popular and common library for Rust parsing operations is \textsf{syn}. Although \textsf{syn} only allows parsing of pure Rust code it is easily extendable. And because we mostly use Rust compatible syntax elements (albeit different semantics) we can use existing parser functions from \textsf{syn}. We have transformed the grammar (\ref{rerust:impl:formal}) so that it is possible to parse with LL(1). 

In Figure \ref{fig:diamond-ast} we show the \ac{AST} for the diamond example. Each \lstinline{ReLocal} node corresponds to a \lstinline{let}-statement from Listing \ref{lst:diamond-pattern} whereby the order remains the same.

\begin{figure}[htpb]
\tikzstyle{every node}=[anchor=west]
    \begin{tikzpicture}[%
  grow via three points={one child at (0.3,-0.5) and
  two children at (0.3,-0.5) and (0.3,-1)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {ReBlock}
    child { node {ReLocal} 
        child {node {ReIdent \lstinline{x}}}
        child {node {VarExpr \lstinline{Var::<u32>(1u32)}}}}
    child [missing] {}
    child [missing] {}
    child { node {ReLocal} 
      child {node {ReIdent \lstinline{y}}}
      child {node {MapExpr}
        child {node {ReIdent \lstinline{x}}}
        child {node {ReClosure \lstinline{x * 2}}}}}
    child [missing] {}
    child [missing] {}
    child [missing] {}
    child [missing] {}
    child { node {ReLocal} 
      child {node {ReIdent \lstinline{z}}}
      child {node {MapExpr}
        child {node {ReIdent \lstinline{x}}}
        child {node {ReClosure \lstinline{x * 3}}}}}
    child [missing] {}
    child [missing] {}
    child [missing] {}
    child [missing] {}
    child { node {ReLocal}
      child { node {ReIdent \lstinline{t}} }
      child { node {MapExpr}
        child { node {GroupExpr} 
          child { node {ReIdent \lstinline{y}} }
          child { node {ReIdent \lstinline{z}} }}
        child [missing] {}
        child [missing] {}
        child { node {ReClosure \lstinline{y + z}} }
        }};
    \end{tikzpicture}
    \centering
    \caption{Simplified AST for the diamond pattern}
    \label{fig:diamond-ast}
\end{figure}

\subsection{Transformation}
\label{rerust:impl:compiler:transform}
At this point we have an \ac{AST} that describes the syntactic structure of our \rerust program. But in contrast to compilers of languages whose syntactic structure follows its semantic structure, we cannot immediately begin with code generation. An \ac{AST} is insufficient to be used as \ac{DG} which is what we need for the next compiler phase. Although both data structures represent graphs, the difference between \ac{AST}s and \ac{DG}s is that \ac{AST}s can not have multiple incoming edges on a node which is strictly required for \ac{DG}s that want to combine multiple data streams.

Let us analyze the process by looking at the example from Figure \ref{fig:diamond-ast}. To construct a \ac{DG} from \rerust \ac{AST}s we iterate through each \lstinline{let}-statement from top to bottom which are denoted as \lstinline{ReLocal} \ac{AST} nodes. Because reactives can only be referenced after they have already been defined we deduce that data flows from top to bottom. However, inside \lstinline{ReLocal} nodes the direction of dataflow is reversed. First, the right-hand side expression of a \lstinline{let}-statement is evaluated. The computed value is then transferred to a new node which is identified by the left-hand side \lstinline{ReIdent}. Right-hand side expressions, like \lstinline{VarExpr}, \lstinline{MapExpr} or \lstinline{GroupExpr} model a traditional dataflow whose direction is from left to right. An expression always has one output reactive and one or more input reactives. With this information we can construct a \ac{DG} in one pass.

\begin{lstlisting}[caption=Pseudo code for DG generation,label=lst:dg-pseudo]
var graph
for reLocal in reBlock {
  val exprNode = visit(reLocal.expr)
  val nameNode = graph.addNode(NameNode(reLocal.ident)
  graph.addEdge(exprNode, nameNode)
}

fn visit(expr) -> Node {
  match expr {
    ReIdent -> { //lookup corresponding node in graph and return it }
    Var -> { graph.addNode(VarNode) }
    Group -> ...
    ...
    Map -> { 
      val leftNode = visit(expr.leftExpr)
      val mapNode = graph.addNode(MapNode) 
      graph.addEdge(leftNode, mapNode)
    }
    Fold -> ...
    ...
  }
}
  
\end{lstlisting}

Listing \ref{lst:dg-pseudo} illustrates the algorithm to perform an \ac{AST} to \ac{DG} transformation. We iterate through all \lstinline{let}-statements in the order they are defined and visit their associated expression. If an expression is visited, it will add new nodes and edges to the graph in compliance to the direction of the dataflow. So all left-hand side parts of expressions are visited first before they add a new node for their own expression. After an expression visit has been finished it returns its own node to the caller. Finally, we can finish the \lstinline{ReLocal} transformation by adding a new special \lstinline{Name} node. This type of node is intended to act as marker node for interface generation in the next phase. It has no fundamental dataflow impact as it simply forwards incoming values to its children. It is also the only type of node that can have multiple outputs, because expressions only allow combining multiple outputs but have only a single output themselves. With named nodes we can reference a resulting node from a previous \lstinline{ReLocal} statement and thus add multiple outgoing connections from a single node. Similarly, we use a \lstinline{Group} node to combine multiple reactive outputs into one input. These meta nodes can be observed in Figure \ref{fig:diamond-dg-internal} where \lstinline{x} serves as an example for a \lstinline{Name} node and \lstinline{(y,z)} for a \lstinline{Group} node.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[yscale=-1]
    \tikzset{vertex/.style = {shape=rectangle,draw,minimum size=1.5em,anchor=center}}
    \tikzset{edge/.style = {->,> = latex'}}
    \node[vertex] (var) at (1,0) {Var::<u32>(1u32)};
    \node[vertex] (x) at (1,1) {x};
    \node[vertex] (map0) at (0,2) {map(x * 2)};
    \node[vertex] (y) at (0,3) {y};
    \node[vertex] (map1) at (2,2) {map(x * 3)};
    \node[vertex] (z) at (2,3) {z};
    \node[vertex] (g) at (1,4) {(y,z)};
    \node[vertex] (map2) at (1,5) {map(y + z)};
    \node[vertex] (t) at (1,6) {t};
    \draw[edge] (var) to (x);
    \draw[edge] (x) to (map0);
    \draw[edge] (x) to (map1);
    \draw[edge] (map0) to (y);
    \draw[edge] (map1) to (z);
    \draw[edge] (y) to (g);
    \draw[edge] (z) to (g);
    \draw[edge] (g) to (map2);
    \draw[edge] (map2) to (t);
    \end{tikzpicture}
    \caption{Internal DG for \rerust}
    \label{fig:diamond-dg-internal}
\end{figure}

For easier code generation purposes we annotate each \ac{DG} node with an output type. This information is not checked but needed to generate a correct contracts for function interfaces. If two types do not match each other, the program would still not compile because the Rust compiler does check the complete generated code at the end anyway.

All \ac{DG} nodes contain references to their \ac{AST} counterpart. Except for the additional type annotation, which is a reference in most cases as well, there is no additional annotation. The user-defined logic remains untouched and will simply be embedded in the resulting code.

\subsection{Reactive semantics}
In section \ref{rerust:ex:chat} we have already discovered \emph{source} and \emph{derived} reactives. To reiterate, \emph{source} reactives provide an interface for foreign code while \emph{derived} reactives manage dataflow inside \rerust programs. Although their effective interface is very similar, \lstinline{Var} and \lstinline{Evt}, the two \emph{source} reactives, have some important semantic distinctions. Both reactives can be updated by sending new values to the program input queue. However, while the value of \lstinline{Var} is defined at any point in time, \lstinline{Evt} can only be read when there is a new value in queue. Because events are distinct, single-use objects, they are only available for a single iteration. This has some implications for reactives that are children to these source reactives. Descendant reactives of \lstinline{Evt} can also only be evaluated if a new value is available, this applies to all descendants not only direct ones. If a derived reactive is descendant of multiple \lstinline{Evt} sources, it can only be evaluated if all \lstinline{Evt} reactives are ready (AND). For \lstinline{Var} reactives though, descendants are evaluated if at least one \lstinline{Var} is ready (OR). For reactives that depend on a combination of both types the combined condition is expressed by:

\begin{equation}
\label{eq:condition}
\bigvee_{i=0}^n var_i \implies \bigwedge_{i=0}^k evt_i
\end{equation}

The other class of reactives is known as \emph{derived reactives}. They can depend directly on source reactives or on other derived reactives. If they depend on at least one \lstinline{Evt} directly or indirectly, they are automatically treated like \lstinline{Evt} reactives. This means that the readiness condition for their children treats them as \lstinline{Evt}. Otherwise, if no \lstinline{Evt} dependencies exist, a reactive is automatically treated as \lstinline{Var}.

Following derived reactives are available:

\begin{description}
\item[map] is a stateless reactive that takes a value of type \textit{A} and returns a value of type \textit{B}. It can be used with continuous and discrete reactives and will belong to the same family as its parent reactive. On definition a side-effect free function has to be provided.
\item[fold] reactives provide means to accumulate state between subsequent \ac{DG} evaluations. Both discrete and continuous reactives are allowed as inputs while the output is always continuous. This is the only way to cross from the discrete family to the continuous family of reactives. When triggered the associated closure is evaluated with two parameters, its accumulator value from last evaluation and the new value of the parent reactive, returning a (possibly) changed accumulator. Folds also take a value of type \textit{A} and output a value of type \textit{B} which is the accumulator.
\item[filter] does exactly what its name suggests. If its parent reactive changes it will apply a filter function to this value. Depending on the condition this can be used to manually prevent the execution of child reactives. A \lstinline{false} condition will indicate for subsequent reactives that this filter reactive has not changed even if its parent has. Filter will take a value of type \textit{A} and output a value of type \textit{A}.
\item[choice (||)] takes exactly two reactives as inputs and returns only one value. Choice has two inputs of type \textit{A} and one output of type \textit{A}. Inputs can be any reactive as long as their output has the same Rust type. If the left-hand reactive has changed, its value will be forwarded to all children. If the left-hand reactive has not changed and the right-hand reactive has, the right-hand value will be returned. If neither reactive has changed, this choice reactive will not change either.
\end{description}

\subsection{Code generation}
\label{rerust:codegen}
In the final phase our compiler generates Rust code from a \ac{DG}. Each \rerust program is similarly structured and uses the same skeleton code into which the individual code of all reactives is embedded. These individual parts are generated in a breadth-first search and then accumulated into bigger chunks of logic. These big chunks are then inserted into our skeleton at their respective positions. We will explain later why a breadth-first search is required but before that let us go trough the generated code from top to bottom.

\begin{lstlisting}[language=Rust,style=colouredRust,caption=Program struct,label=lst:prog-struct]
pub struct Program {
    state: State,
    observers: Observers,
    receiver: Receiver<Input>,
    sink: Sink,
}
\end{lstlisting}

At the core we have a \lstinline{Program} struct (Listing \ref{lst:prog-struct}) which represents an instance of a \rerust program. While \lstinline{state} is represents the state between evaluations, \lstinline{observers} contains the observing closures for named reactives. As source reactives can be altered from outside, \lstinline{receiver} contains the receiving part of \lstinline{sink} which allows sending changes to these sources. These changes are represented as an \lstinline{Input} object that has a distinct field for each source reactive that has a name. The input struct for the aforementioned chat example is shown in Listing \ref{lst:input-struct}. As one can observe, the names of \lstinline{index}, \lstinline{room2}, \lstinline{text} and \lstinline{name} have been replaced by automatically generated identifiers. This matches the structural specialties shown in Figure \ref{fig:diamond-dg-internal} which shows that reactives and their names are separate nodes. 

\begin{lstlisting}[language=Rust,style=colouredRust,caption=Input struct for chat example,label=lst:input-struct]
pub struct Input {
    var_6: Option<usize>,
    var_5: Option<Vec<String>>,
    evt_1: Option<String>,
    var_0: Option<String>,
}
\end{lstlisting}

The corresponding interface is generated as a function for \lstinline{Input}, Listing \ref{lst:input-interface} shows the interface for \lstinline{text} which sets the value of \lstinline{evt_1}. Note that all input values are wrapped as options, otherwise one must always change all reactives at once.

\begin{lstlisting}[language=Rust,style=colouredRust,caption=Input interface,label=lst:input-interface]
pub fn set_text(&mut self, value: String) {
    self.evt_1 = Some(value);
}
\end{lstlisting}

For an \lstinline{Input} object to be useful we need a \lstinline{Sink}. It accepts new \lstinline{Input} objects and manages them in a queue. Each time \lstinline{Program} updates itself it polls the queue for new changes. A special feature of \lstinline{Sink} is its lock-free synchronization technique. Typically there are multiple asynchronous change sources, e.g. a TCP socket and a \ac{UI}. As these need to access the \lstinline{Sink} from different threads, a implementation of \lstinline{Clone} is provided. However, this would not result in synchronization if two different threads want to change the same source reactive. Tackling this issue is usually done by adding a mutual exclusion lock that only allows one modification at a time. This is exactly what we want to avoid, so to achieve synchronization we use a set of singleton objects. In this scenario, each source reactive has a singleton \emph{key}. This object can be transferred freely between threads and clones of \lstinline{Sink} which have a special \emph{slot} for each \emph{key} object. If a \lstinline{Sink} instance receives an \lstinline{Input} object that contains a value for a reactive whose slot is not occupied, that input object is invalid to be sent from this instance. That way we guarantee that each reactive can only be modified from one thread at a time.

\begin{lstlisting}[language=Rust,style=colouredRust,caption=Program::update() function,label=lst:update-fn]
fn update(state: &mut State, receiver: &mut Receiver<Input>) -> Change {
    let mut change = Change::default();
    let result = receiver.try_recv();
    match result {
        Ok(inputs) => {
            if inputs.var_6.is_some() {
                state.var_6 = inputs.var_6;
                change.var_6 = true;
            }
            //...
            if inputs.evt_1.is_some() {
                state.evt_1 = inputs.evt_1;
                change.evt_1 = true;
            } else {
                state.evt_1 = None;
            }
            //...
            if !state.evt_1.is_none() && !state.var_0.is_none() {
                if change.evt_1 || change.var_0 {
                    change.group_2 = true;
                }
                state.group_2 =
                    Some((state.evt_1.clone().unwrap(), state.var_0.clone().unwrap()));
            }
            if change.group_2 {
                let val = state.group_2.clone().unwrap();
                let result = Self::map_3(val);
                if state.map_3.is_none() || result != *state.map_3.as_ref().unwrap() {
                    change.map_3 = true;
                    state.map_3 = Some(result);
                }
            } else if state.group_2.is_none() {
                state.map_3 = None;
            }
            //...
        }
        //...
    }
    change
}
//...
#[inline]
fn map_3((t, n): (String, String)) -> String {
    format!("{}: {}", n, t)
}
\end{lstlisting}

Finally, we analyze the generated code that actually expresses \rerust logic. The standard operating procedure for a constructed Program consists of three phases:
\begin{enumerate}
    \item Poll new inputs from the receiver queue. This potentially yields a instance of \lstinline{Input}.
    \item Update all reactive states based on the new input.
    \item Notify all registered observers.
\end{enumerate}
This routine is to be executed regularly by repeatedly calling \lstinline{Program::run()}. 

Listing \ref{lst:update-fn} shows the polling and updating of reactives. First we poll the queue in line 3 and if a new value is available, we proceed with line 6. This part contains a set of \lstinline{if-else} blocks, each representative of its own reactive. They are ordered in the same way as a breadth-first search of the \ac{DG} would visit them. This static scheduling guarantees \emph{glitch-freedom} as ReactiFi~\citep{reactifi} has shown.

Each \lstinline{if}-condition checks whether a reactive is executable by testing if its predecessor has changed and if condition \ref{eq:condition} holds. In that case the value will be updated and a flag in a \lstinline{change} matrix will be set. This flag is later used to determine which observers to notify about the change. The update is usually done by calling the associated update closure but is dependent on the type of reactive used. Line 43 shows an update function for \lstinline{map_3}. This is the closure from line 4 of the message reactive in Listing \ref{lst:chat-example}.

