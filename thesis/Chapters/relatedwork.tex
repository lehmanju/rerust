\chapter{Related work}
\label{related}
In this section we will discuss some alternative approaches for reactive applications. Most notably, \textsf{ReRust} has been inspired by \textsf{ReScala} and \textsf{ReactiFi} which already solved most problems of \ac{FRP}. Additionally, with \textsf{carboxyl/frappe} and \textsf{futures-signals} there are also libraries available in the Rust ecosystem.

\section{ReScala}
\label{related:rescala}
\textsf{ReScala}, as the name suggests, is a reactive library implemented in the Scala programming language. It was originally developed to make the Observer Pattern obsolete and replace it with a more declarative style of programming. The "reactive paradigm" of \textsf{ReScala} is derived from \ac{FRP} and event-driven programming languages like C\#, EventJava or EScala. A \textsf{ReScala} program is conceptually a dataflow graph with a number of nodes, known as reactives. Each reactive has an update function attached that describes how it should recompute its value. Because we only want to get notified if a value actually changes, a reactive only triggers if at least one of its predecessors in the dataflow graph has changed its value. Special schedulers organize execution order of nodes and therefore prevent the program from reaching an inconsistent state. \textsf{ReScala} therefore satisfies the requirement of \emph{glitch-freedom}.

Because the Scala language runs on the \ac{JVM}, \textsf{ReScala} is unsuited to be used on devices with limited resources or without a proper runtime. As of the time of writing, there are efforts to use native Scala which would extend the list of possible targets. Still, predicting resource usage would be impossible as scheduling and dependency evaluation is done dynamically at runtime.

\section{ReactiFi}
\label{related:reactifi}
Similarly to \textsf{ReScala}, \textsf{ReactiFi} is a reactive library building on the same concepts as \textsf{ReScala}. But instead of using runtime scheduling of reactives it leverages the benefits of static scheduling by using a compiler. \textsf{ReactiFi} compiles a Scala \ac{DSL} to C code, addressing more potential targets than \textsf{ReScala}. Before outputting C code the \ac{DG} is type checked and sorted topologically to ensure a correct execution order to satisfy \emph{glitch-freedom}. This static scheduling of reactives happens to also minimize memory usage. In combination with the restriction that data types have to be stack allocated, memory usage is predictable.

Although \textsf{ReactiFi} is specifically designed to be used for Software Defined Networking on embedded Wi-Fi Hardware, their approach is not domain specific. \textsf{ReRust} borrows the concepts of static scheduling and code generation. But unlike C, encapsulated Rust code can be assumed to be safe because of Rusts advanced ownership model. With procedural macros it also integrates nicely into the toolchain, taking a major hurdle to add dataflow semantics to existing code.

\section{carboxyl/frappe}
The first pure Rust library we evaluated has been \textsf{carboxyl}. In their documentation they advertise a library that implements \ac{FRP} in Rust. Another library to mention in this context is \textsf{frappe}, although it builds on the same concepts it is only a re-implementation of \textsf{carboxyl}. For this reason from here on we will only refer to \textsf{carboxyl} but mean to include \textsf{frappe} as well.

The concepts of this library are different to those of \textsf{ReScala} and \textsf{ReactiFi}. According to the documentation their design is based around a proposal by \cite{Elliott2009} which provides means of evaluating \ac{FRP} programs in a push-pull manner. It provides two main abstractions, signals and streams. Streams represent a stream of distinct events. Signals can be created by either providing a constant value or holding a stream value. Either way, signals are stateless, so an important way of changing state over time is missing. Also, there are no guarantees to ensure consistent evaluation, hence \textsf{carboxyl} violates \emph{glitch-freedom}. This can be demonstrated by the simple diamond pattern example we used earlier (Listing \ref{lst:carboxyl-diamond}). The first evaluation of signal \texttt{t} yields the correct solution of \texttt{5}. The second evaluation, however, yields \texttt{17} instead of the correct value \texttt{25}.

\begin{lstlisting}[language=Rust,style=colouredRust,caption=Diamond pattern in carboxyl,label=lst:carboxyl-diamond]
let x_sink = Sink::new();
let x = x_sink.stream().hold(1);
let y = x.map(|x| x * 2);
let z = x.map(|x| x * 3);
let t = z.map(move |x| x + y.sample());

println!("{}", t.sample()); // 5
x_sink.send(5);
println!("{}", t.sample()); // 17
\end{lstlisting}

\section{futures-signals}
\label{related:futures-signals}
This crate had been the most promising Rust library initially, because its abstractions come at almost no cost at all. A \textsf{futures-signals} program operates on an abstraction called signals. The lightness of signals comes from Rusts implementation of futures. Signals can be best described as views on variables, so that each signal is triggered if a variable it observes changes. Various stateless dataflow operators are available to manipulate signals, for example \texttt{map}. But similar to \textsf{carboxyl}, there is no possibility to save state between different computations of a signal. Also, the feature to change multiple variables \emph{at the same time} without triggering multiple reevaluations instead of one is missing. Although the diamond pattern generally works in \textsf{futures-signals}, it is very inconsistent and sometimes there is no computation at all.